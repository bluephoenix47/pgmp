#lang scribble/base
@(require "defs.rkt")
@(require scribble/manual)
@(require scriblib/footnote)
@section[#:tag "examples" "Examples"]
This section presents several macros that use profiling information to
eptimize the expanded code. The first example is @racket{exclusive-cond},
which was mentioned in @secref{intro}. The second is a profile
directed loop unrolling example. While loop unrolling can be done with
block-level profiling, it is simple to do as a macro, and avoids the problem of
reconstructing loops from basic-blocks. The final example is a sequence library
that is conditionally represented using a linked-list or a vector, depending on
profile information.

@subsection{exclusive-cond}
@racket{cond} is a Scheme branching construct, described briefly in in
@secref{intro}. The following example of @racket{cond} shows the
forms it can take.

@todo{insert example cond using all forms}

The first two clauses have a test on the left-hand side and some
expression on the right-hand side. The tests are evaluated in order. The
right-hand side of the first clause with a true left-hand side is evaluated.

The second syntax passes the value of the left-hand side to the function
on the right-hand side, only if the left-hand side evaluates to a true
value. In Scheme, any value that is not @racket{#f} is true, so this
can be used to post-process non-boolean true values. 

That last syntax simple returns the value of the left-hand side if it
evaluates to a true value. The last clause is equivalent to the clause
@racket{(e => (lambda (x) x))}.

@todo{reword uses of ``syntax" above}

@todo{insert exclusive cond}

@; How does exclusive-cond use profile information to implement cond
The @racket{exclusive-cond} macro, figure@~ @todo{figure ref}, shows an
implementation of @racket{cond} that will rearrange clauses based on
the profiling information of the right-hand sides. Since the left-hand
sides will be executed depending on the order of the clauses, profiling
information from the left-hand side is not enough to determine which
clause is true most often. Unfortunately, this means we
cannot @note{By manually hacking source objects, it may be possible
but would not be pretty.} implement the last syntax for @racket{cond}
clauses which has only a left-hand side.

@; How are clauses parsed
In order to sort the clauses, all clauses are parsed before the code is
generated. @racket{exclusive-cond} first parses each clause into a
clause record.  The clause record stores the original syntax for the
clause and the weighted profile count for that clause. @todo{Maybe why
we pick an expression from the body of each clause here, instead of up
there} Since a valid @racket{exclusive-cond} clause is also a valid
@racket{cond} clause, the syntax is simply copied.

@todo{syntax or code? technically syntax, but code is easier to understand}

@; How are clauses emitted in order
After parsing each clause, the clause records are sorted by the profile
weight. Once sorted, a @racket{cond} expression is generated by
emitting each clause in sorted order. If an @racket{else} clause exists, it
is always emitted last.

@todo{example of exclusive-cond generating cond}

@subsubsection{case}
@; How does case work
@racket{case} pattern matching construct that is easily given profile
directed optimization by implementing it in terms of
@racket{exclusive-cond}. @racket{case} takes an expression @racket{key-expr}
and an arbitrary number of clauses, followed by an optional
@racket{else} clause. The left-hand side of each clause is a list of
constants. The right-hand side of the first clause in which @racket{key-expr}
is @racket{eqv?} to some element of the left-hand side is evaluated.
@todo{That sentence is a little awkward.} If @racket{key-expr} is not
@racket{eqv?} to any element of any left-hand side, then the right-hand
side of the @racket{else} clause is evaluated.

@todo{Add an example case}

@; How are clauses parsed
Since @racket{case} permits clauses to have overlapping elements and uses
order to determine which branch to take, we must remove overlapping elements
before clauses can be reordered. Each clause is parsed into the set of
left-hand side keys and right-hand side bodies. Overlapping keys are
removed by keeping only the first instance of each key when processing
the clauses in the original order. After removing overlapping keys, an
@racket{exclusive-cond} is generated. 

@todo{example of case expansion}

@subsection{Loop Unrolling}
Loop unrolling is a standard @todo{standard vs textbook} compiler
optimizations.  However, striking a balance between code growth and
speed is tricky. By using profile information, the compiler can focus on
the most executed loops.  

Some of Scheme's simple loop constructs are basic macros, so we
demonstrate loop unrolling using macros. Profile directed loop unrolling
could be done using block-level profile information, but this would
require associating loops with basic blocks. As this example shows,
doing this as a macro is much simpler, and can handle recursive
recursive functions, not just tail recursive loops.

Still, even in our implementation, we wait until after macro expansion
to do loop unrolling. We still use the source-level profile information,
which is passed through the compiler after macro expansion, but wait
until many more loops can be exposed than only those made 

@subsection{Data type Selection}
