#lang scribble/base
@(require "defs.rkt")
@(require scribble/manual)
@(require scriblib/footnote)
@(require scriblib/figure)
@section[#:tag "examples" "Examples"]
This section presents several macros that use profiling information to
eptimize the expanded code. The first example is @racket[exclusive-cond],
which was mentioned in @secref{intro}. The second is a profile
directed loop unrolling example. While loop unrolling can be done with
block-level profiling, it is simple to do as a macro, and avoids the problem of
reconstructing loops from basic-blocks. The final example is a sequence library
that is conditionally represented using a linked-list or a vector, depending on
profile information.

@subsection{exclusive-cond}
@racket[cond] is a Scheme branching construct, described briefly in in
@secref{intro}. The following example of @racket[cond] shows the
forms it can take.

@todo{insert example cond using all forms}

The first two clauses have a test on the left-hand side and some
expression on the right-hand side. The tests are evaluated in order. The
right-hand side of the first clause with a true left-hand side is evaluated.

The second syntax passes the value of the left-hand side to the function
on the right-hand side, only if the left-hand side evaluates to a true
value. In Scheme, any value that is not @racket[#f] is true, so this
can be used to post-process non-boolean true values. 

That last syntax simple returns the value of the left-hand side if it
evaluates to a true value. The last clause is equivalent to the clause
@racket[(e => (lambda (x) x))].

@todo{reword uses of ``syntax" above}

@todo{insert exclusive cond}

@; How does exclusive-cond use profile information to implement cond
The @racket[exclusive-cond] macro, @figure-ref{exclusive-cond}, shows an
implementation of @racket[cond] that will rearrange clauses based on
the profiling information of the right-hand sides. Since the left-hand
sides will be executed depending on the order of the clauses, profiling
information from the left-hand side is not enough to determine which
clause is true most often. Unfortunately, this means we
cannot @note{By manually hacking source objects, it may be possible
but would not be pretty.} implement the last syntax for @racket[cond]
clauses which has only a left-hand side.

@; How are clauses parsed
In order to sort the clauses, all clauses are parsed before the code is
generated. @racket[exclusive-cond] first parses each clause into a
clause record.  The clause record stores the original syntax for the
clause and the weighted profile count for that clause. @todo{Maybe why
we pick an expression from the body of each clause here, instead of up
there} Since a valid @racket[exclusive-cond] clause is also a valid
@racket[cond] clause, the syntax is simply copied.

@todo{syntax or code? technically syntax, but code is easier to understand}

@; How are clauses emitted in order
After parsing each clause, the clause records are sorted by the profile
weight. Once sorted, a @racket[cond] expression is generated by
emitting each clause in sorted order. If an @racket[else] clause exists, it
is always emitted last.

@todo{example of exclusive-cond generating cond}

@subsubsection{case}
@; How does case work
@racket[case] pattern matching construct that is easily given profile
directed optimization by implementing it in terms of
@racket[exclusive-cond]. @racket[case] takes an expression @racket[key-expr]
and an arbitrary number of clauses, followed by an optional
@racket[else] clause. The left-hand side of each clause is a list of
constants. The right-hand side of the first clause in which @racket[key-expr]
is @racket[eqv?] to some element of the left-hand side is evaluated.
@todo{That sentence is a little awkward.} If @racket[key-expr] is not
@racket[eqv?] to any element of any left-hand side, then the right-hand
side of the @racket[else] clause is evaluated.

@todo{Add an example case}

@; How are clauses parsed
Since @racket[case] permits clauses to have overlapping elements and uses
order to determine which branch to take, we must remove overlapping elements
before clauses can be reordered. Each clause is parsed into the set of
left-hand side keys and right-hand side bodies. Overlapping keys are
removed by keeping only the first instance of each key when processing
the clauses in the original order. After removing overlapping keys, an
@racket[exclusive-cond] is generated. 

@todo{example of case expansion}

@subsection{Loop Unrolling}
Loop unrolling is a standard @todo{standard vs textbook} compiler
optimizations.  However, striking a balance between code growth and
speed is tricky. By using profile information, the compiler can focus on
the most executed loops.  

Some of Scheme's basic loop constructs are simple macros, so we
demonstrate loop unrolling using macros. Profile directed loop unrolling
could be done using block-level profile information, but this would
require associating loops with basic blocks, and cannot easily handle
arbitrary recursive functions. As this example shows, doing this as a
macro is much simpler, and can handle recursive functions, not
just tail recursive loops.
@todo{Make those last two sentances shorter}
@todo{Say somethign about named lets with non-tail call sites. (other than what you've already said. or maybe not)}

Still, even in our implementation, we wait until after macro expansion
to do loop unrolling. We still use the source-level profile information,
which is passed through the compiler after macro expansion, but wait
until many more loops can be exposed than only those made by a single macro.
@todo{That paragraph sucks, and is out of place.}

@; Explain a basic let-loop
A loop can be written using a named-let in Scheme, as shown in
@figure-ref{fact5}. This defines a recursive function @racket[fact] and
calls it with the argument @racket[5]. This named-let might normally be
defined simply using @racket[letrec] as seen in
@figure-ref{named-let-simple}.

@todo{insert named-let code}

@; Explain how to do a profile directed named let unrolling
@racket[named-let] (@figure-ref{named-let}) defines a macro that unrolls
the body of the loop between 1 and 3 times, depending on profile
information. The macro uses profile information associated with the body
of the loop to determine how frequently the loop is executed. Loops
that take up less than 10% of the max execution count are not unrolled
at all. If a loop is executed 100% of the max execution count, then it
may be unrolled 3 times. 

@; Explain multiple call sites
Note that in this macro, @emph{each} call site is unrolled the same
number of times. A named-let may have multiple recurisve calls, some of
which may be more frequently used than others. A more clever macro could
unroll each call site a different number of times, depending on how many
times that particular call is executed. This would allow more fine grain
control over code growth.

Similar macros are easy to write for @racket[do] loops, and even
@racket[letrec] to unroll general recursive functions.


@subsection{Data type Selection}
