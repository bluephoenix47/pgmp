#lang scribble/base
@(require "defs.rkt")
@(require scribble/manual)
@(require scriblib/footnote)
@(require scriblib/figure)
@section[#:tag "examples" "Examples"]
This section presents several macros that use profiling information to
eptimize the expanded code. The first example is @racket[exclusive-cond],
which was mentioned in @secref{intro}. The second is a profile
directed loop unrolling example. While loop unrolling can be done with
block-level profiling, it is simple to do as a macro, and avoids the problem of
reconstructing loops from basic-blocks. The final example is a sequence library
that is conditionally represented using a linked-list or a vector, depending on
profile information.

@subsection{exclusive-cond}
@racket[cond] is a Scheme branching construct, described briefly in in
@secref{intro}. The following example of @racket[cond] shows the
forms it can take.

@todo{insert example cond using all forms}

The first two clauses have a test on the left-hand side and some
expression on the right-hand side. The tests are evaluated in order. The
right-hand side of the first clause with a true left-hand side is evaluated.

The second syntax passes the value of the left-hand side to the function
on the right-hand side, only if the left-hand side evaluates to a true
value. In Scheme, any value that is not @racket[#f] is true, so this
can be used to post-process non-boolean true values. 

That last syntax simple returns the value of the left-hand side if it
evaluates to a true value. The last clause is equivalent to the clause
@racket[(e => (lambda (x) x))].

@todo{reword uses of ``syntax" above}

@todo{insert exclusive cond}

@; How does exclusive-cond use profile information to implement cond
The @racket[exclusive-cond] macro, @figure-ref{exclusive-cond}, shows an
implementation of @racket[cond] that will rearrange clauses based on
the profiling information of the right-hand sides. Since the left-hand
sides will be executed depending on the order of the clauses, profiling
information from the left-hand side is not enough to determine which
clause is true most often. Unfortunately, this means we
cannot @note{By manually hacking source objects, it may be possible
but would not be pretty.} implement the last syntax for @racket[cond]
clauses which has only a left-hand side.

@; How are clauses parsed
In order to sort the clauses, all clauses are parsed before the code is
generated. @racket[exclusive-cond] first parses each clause into a
clause record.  The clause record stores the original syntax for the
clause and the weighted profile count for that clause. @todo{Maybe why
we pick an expression from the body of each clause here, instead of up
there} Since a valid @racket[exclusive-cond] clause is also a valid
@racket[cond] clause, the syntax is simply copied.

@todo{syntax or code? technically syntax, but code is easier to understand}

@; How are clauses emitted in order
After parsing each clause, the clause records are sorted by the profile
weight. Once sorted, a @racket[cond] expression is generated by
emitting each clause in sorted order. If an @racket[else] clause exists, it
is always emitted last.

@todo{example of exclusive-cond generating cond}

@subsubsection{case}
@; How does case work
@racket[case] pattern matching construct that is easily given profile
directed optimization by implementing it in terms of
@racket[exclusive-cond]. @racket[case] takes an expression @racket[key-expr]
and an arbitrary number of clauses, followed by an optional
@racket[else] clause. The left-hand side of each clause is a list of
constants. The right-hand side of the first clause in which @racket[key-expr]
is @racket[eqv?] to some element of the left-hand side is evaluated.
@todo{That sentence is a little awkward.} If @racket[key-expr] is not
@racket[eqv?] to any element of any left-hand side, then the right-hand
side of the @racket[else] clause is evaluated.

@todo{Add an example case}

@; How are clauses parsed
Since @racket[case] permits clauses to have overlapping elements and uses
order to determine which branch to take, we must remove overlapping elements
before clauses can be reordered. Each clause is parsed into the set of
left-hand side keys and right-hand side bodies. Overlapping keys are
removed by keeping only the first instance of each key when processing
the clauses in the original order. After removing overlapping keys, an
@racket[exclusive-cond] is generated. 

@todo{example of case expansion}

@subsection{Loop Unrolling}
Loop unrolling is a standard @todo{standard vs textbook} compiler
optimizations.  However, striking a balance between code growth and
speed is tricky. By using profile information, the compiler can focus on
the most executed loops.  

Some of Scheme's basic loop constructs are simple macros, so we
demonstrate loop unrolling using macros. Profile directed loop unrolling
could be done using block-level profile information, but this would
require associating loops with basic blocks, and cannot easily handle
arbitrary recursive functions. As this example shows, doing this as a
macro is much simpler, and can handle recursive functions, not
just tail recursive loops.
@todo{Make those last two sentances shorter}
@todo{Say somethign about named lets with non-tail call sites. (other than what you've already said. or maybe not)}

Still, even in our implementation, we wait until after macro expansion
to do loop unrolling. We still use the source-level profile information,
which is passed through the compiler after macro expansion, but wait
until many more loops can be exposed than only those made by a single macro.
@todo{That paragraph sucks, and is out of place.}

@; Explain a basic let-loop
A loop can be written using a named-let in Scheme, as shown in
@figure-ref{fact5}. This defines a recursive function @racket[fact] and
calls it with the argument @racket[5]. This named-let might normally be
defined simply using @racket[letrec] as seen in
@figure-ref{named-let-simple}.

@todo{insert named-let code}

@; Explain how to do a profile directed named let unrolling
@racket[named-let] (@figure-ref{named-let}) defines a macro that unrolls
the body of the loop between 1 and 3 times, depending on profile
information. The macro uses profile information associated with the body
of the loop to determine how frequently the loop is executed. Loops
that take up less than 10% of the max execution count are not unrolled
at all. If a loop is executed 100% of the max execution count, then it
may be unrolled 3 times. 

@; Explain multiple call sites
Note that in this macro, @emph{each} call site is unrolled the same
number of times. A named-let may have multiple recursive calls, some of
which may be more frequently used than others. A more clever macro could
unroll each call site a different number of times, depending on how many
times that particular call is executed. This would allow more fine grain
control over code growth.

Similar macros are easy to write for @racket[do] loops, and even
@racket[letrec] to unroll general recursive functions.

@subsection{Data type Selection}
@; Motivate an example that normal compilers just can't do
The previous optimizations focus on low level changes that can improve
code performance. Reordering clauses of a @racket[cond] can improve
speed by maximizing straight-line code emitted later in the compiler.
Loop unrolling can reduce overhead associate with loops and maximize
straight-line code emitted later in the compiler. While profile directed
meta-programming enables more of such low level optimizations, it
also enables higher level decisions normally done by the programmer

@; Introduce example
@todo[Add sequence-datatype figure]
Consider a program in which a sequence is obviously required, but which
data structure is best used to implement the sequence is not obvious.
This example shows how to choose the implementation based on profile
information. The example in @figure-ref{sequence-datatype} chooses
between a list and a vector. If @racket[seq-set!] and @racket[seq-ref]
operations are used more often than @racket[seq-map] and
@racket[seq-first] then a @racket[vector] is used, otherwise a
@racket[list] is used.

@todo[Add example use of sequence-datatype macro figure]
@; Discuss quirks in example implementation
The example requires the names of the sequence functions to be given.  
The unique source information attached to each name is used to profile
the operations of that @emph{particular} sequence. The definitions of
each operation evaluate the name to ensure function inlining does not
distort profile counts. A clever compiler might try to throw out the
effect-free reference to @racket[name] in the body of each operation, so
this implementation is fragile.

@subsection{Working with block-level profiling}
@todo{Not sure where this subsection belongs}
Optimizations based on source-level profile information may result in a
different set of blocks than the blocks generated on a previous run of a
program. If blocks are profiled naively, for instance, by assigning each
block a number in the order in which the blocks are generated, then the
block numbers will not be consistent after optimizing with source
information. Therefore optimization using source profile information and
those using block profile information cannot be done after a single
profiled run of a program.

To take advantage of both kinds of optimizations, we use the following
workflow. First a program is compiled and instrumented to collect
source-level information. A profiled run collects only the source-level
information. The program is recompiled and optimized using that
source-level information, and instrumented to collect block-level
information. A profiled run collects only the block-level information.
The program is finally recompiled and optimized using both the
source-level information and the block-level information.

While the workflow seems to significantly complicate the compilation
process, the different between using only block-level profiling
and using both source-level and block-level profiling is small. To use
any kind of profile directed optimizations requires a 300% increase in
the number of steps (from compile to compile-profile-compile). To use
both source-level and block-level profile directed optimizations
requires only an additional 66% increase in number of steps
(compile-profile-compile to compile-profile-compile-profile-compile).
