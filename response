Review two is concerned that the focus of our paper is too narrow for
a conference such as PLDI. On the contrary, this work combines popular
techniques which frequently appear at PLDI into a single general-purpose
approach. For instance, Hawkins et. al. (PLDI 2011, PLDI 2012) use special-purpose
meta-programming techniques, while Chen et. al. (PLDI 2006) use
profile-guided optimization. In fact, profile-guided optimization and
meta-programming are featured in several of the most influential PLDI
papers. For instance Pettis and Hansen (PLDI 1990) introduce
profile-guided code positioning, while Frigo (PLDI 1999) describes a
meta-program for generating performant C code.


Reviewer one asks about performance evaluation. Our case studies have been
found to be effective in the literature, and a performance evaluation of
them in our system would measure the specifics of our Racket and
Chez implementations more than the benefits of our technique.

The compile-time overhead will be specific to the optimization. For
instance, conditional branch reordering is a simple local change and
will likely not have much overhead. However, performing function
inlining as a profile-guided meta-program may be
complicated; the meta-program must account for global changes to code
size, may be run many times depending on the number of function calls,
and slow down later stages of compilation.

The profiling overhead will be specific to the profiler used by the
implementation of our technique. For instance, the profiler we use in
our Chez Scheme implementation is based on standard, efficient profiling
techniques. Previous work measured the overhead of the Chez Scheme
profiler at about 9% additional running time on average [2].  The
profiling library used in our Racket implementation has overhead ranging
from 3% to 33% [1].

We will add a discussion of performance and overhead to the paper.

Review one asks if the meta-programming approach is general enough to
permit path and locality profiling. As long as costs measured by the
profiler can be mapped to source program points, our techniques should
apply. While path profiling could inform optimizations such as inlining,
which can be expressed using our technique, we have not given much
thought to locality profiling or how we would use this information in
our system.  We conjecture locality information is better used by low
level optimizations.  However, it is possible that some clever
meta-programs could take advantage of locality profiling in our system.

Review one notes that we do not discuss how profiling or
meta-programming work in other meta-programming systems, such as
Template Haskell or MetaML. We will add a discussion of other
meta-programming systems and how our technique might apply to them.

Review one asks how aspect-oriented programming, which can be used to
insert profiling code, compares to meta-programming. Aspect-oriented
programming (AOP) is orthogonal to meta-programming. Our technique should work
with an AOP based profiler, so long as profile points can be mapped to
program points.


Review three asks how do we ensure that profile points are not mixed up,
for instance, when reordering conditional branches. In our
implementations, profile points are introduced in two ways:

1) The language parser attaches source location information (filename, line
number, character position) to each source expression. We use this
source location to uniquely identify profile points. These profile
points are always generated deterministically. As they are attached
directed to the source expressions we transform, they are implicitly
preserved during macro transformations, such as branch reordering.

2) The meta-program explicitly introduces a new profile point with
make-profile-point. In this case, make-profile-point must generate the
profile point deterministically. For instance, suppose we explicitly
annotate the following conditional with profile points:

...
(define p1 (make-profile-point))
(define p2 (make-profile-point))

#'(cond
    [(test1 #,(annotate p1 #'e1))]
    [(test2 #,(annotate p2 #'e2))])

If p1 and p2 are not generated deterministically, then using them to
lookup profile information in later runs will result in potentially
arbitrary results. In our implementations, we solve this by providing
make-profile-point a source expression as input, and use the source
location information as a starting point to deterministically generate
new profile points. In the above example, we would instead write:

...
(define p1 (make-profile-point #'e1))
(define p2 (make-profile-point #'e2))

#'(cond
    [(test1 #,(annotate p1 #'e1))]
    [(test2 #,(annotate p2 #'e2))])




[1] http://www.ccs.neu.edu/racket/pubs/NU-CCIS-14-01.pdf

[2] Robert G Burger and R Kent Dybvig. An infrastructure for profile-
driven dynamic recompilation. In Proc. Computer Languages, 1998.
Proceedings. 1998 International Conference on, 1998.
http://www.cs.indiana.edu/~dyb/pubs/pdrtc.pdf

[3] http://www.sigplan.org/Awards/PLDI/

[4] Wen-ke Chen, Sanjay Bhansali, Trishul Chilimbi, Xiaofeng Gao, and Weihaw
Chuang. Profile-guided Proactive Garbage Collec- tion for Locality
Optimization. In Proc. The 2006 ACM SIG- PLAN Conference on Programming
Language Design and Im- plementation, 2006b. http://doi.acm.org/10.1145/
1133981.1134021

[5] Peter Hawkins, Alex Aiken, Kathleen Fisher, Martin Rinard, and Mooly
Sagiv. Data Representation Synthesis. In Proc. Proceed- ings of the 32Nd
ACM SIGPLAN Conference on Programming Language Design and
Implementation, 2011. http://doi. acm.org/10.1145/1993498.1993504

[6] Peter Hawkins, Alex Aiken, Kathleen Fisher, Martin Rinard, and Mooly
Sagiv. Concurrent Data Representation Synthesis. In Proc. Proceedings of
the 33rd ACM SIGPLAN Conference on Programming Language Design and
Implementation, 2012. http://doi.acm.org/10.1145/2254064.2254114

[7] Matteo Frigo. 1999. A fast Fourier transform compiler. In
Proceedings of the ACM SIGPLAN 1999 conference on Programming language
design and implementation (PLDI '99). ACM, New York, NY, USA, 169-180.
DOI=10.1145/301618.301661 http://doi.acm.org/10.1145/301618.301661

[8] Karl Pettis and Robert C. Hansen. 1990. Profile guided code
positioning. In Proceedings of the ACM SIGPLAN 1990 conference on
Programming language design and implementation (PLDI '90). ACM, New
York, NY, USA, 16-27. DOI=10.1145/93542.93550
http://doi.acm.org/10.1145/93542.93550
